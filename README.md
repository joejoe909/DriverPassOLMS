# **DriverPassOLMS** 
### Driver Pass Online Learning System. 

<br>

# Introduction 
<p>	The CS-255 System Analysis and Design course at SNHU exposed Students to the System Analyst/Designer's role in the software development life cycle. Systems Analysts play an essential role in software design, and much of the effort they provide in the Software Development Lifecycle happens before a single line of code is written. </p>

<br>

<p> In CS-255, students are placed in the scenario of designing the Driver Pass Website. This website allows Customers to schedule in-person Driving lessons and take online tests to prepare students for Driving tests. This business model was based on the fact that a high percentage of Test takers take the Driving test and fail on the first attempt. Driver Pass is meant to prepare students for the Driver Test and pass the first time. </p>

<br>

<p> The role of the SNHU students was that of the Systems Analyst, and they would have to construct the Following Documents included in this repo: </p>

-  **Business Requirements Document:** This outlines the purpose of the system, Objectives, and Goals, Definess Functional and Non-Functional Requirements, and Limitations. Additionally, Gnatt charts are generated to illustrate the project timeline. 
- **Template Research:** The goal of this lesson was to research templates in the form of Learning Management Systems. 
- **Application Modeling Short Paper:** Discusses the implementation of Object and Process modeling in the DriverPass scenario and compares the two modeling techniques.
- **System Design Document:** A Customer deliverable in the form of UML Use Case Diagrams, Activity Diagrams, UML Sequence Diagrams, and UML Class Diagrams Additionally provides an overview of the technical, functional, and non-functional requirements and a formal recommendation. 

<br>

# What I did well in this course.
<p> Researching an LMS, I found this part of the project extremely interesting. I found a pre-existing template in the form of Git Hub Repo called Pupil first. This repo is a very informative pre-existing code base that can help anyone get an LMS up and running using current WebApp solutions using systems such as Heroku, React, Ruby on Rails, and Graph QL. In addition construction of this system would expose Developers to Cloud technologies that would need to be implemented to get the system up and running. </p>

<br>

# Revise
<p> If I had to revise any of these efforts, I would state that I'm constantly trying to discern the difference between functional and non-functional requirements. While this was a challenge, I formed a list of facts that distinguish the two. </p>

<p> **Non-Functional Requirments:** Refer to behavioral properties the system must possess. Non-functional requirements cover the following: </p>
- Operational in Nature
- Cover Performance
- Security
- Cultural and Political

<p> Non-functional requirements are used in design when decisions are made about the UI, hardware, software, and System Architecture. </p>
<br>

<p> **Functional Requirements:** Relate directly to a process a system needs to perform or the information it needs to contain. </p>

<br>

# Interpreting User Needs: 
<p> Through the mock meetings with the client, discussion on what functions and needs they're trying to perform and how they intend to create an income stream. Timelines were discussed. From these meetings, functional and non-functional requirements were formed Gnatt charts were constructed to provide an overview of the project timeline. Functional Requirements were used to build structural and behavioral models. Non-Functional Requirements were used to implement security and GUI design. </p>

<br>

# Approach to designing software.
<p> The lessons learned in this class are for systems analysts and software developers to avoid the ill-fated code-first approach. If documentation is in place or has gone missing - it will not matter. If you start from a design process first, you will have aided the company, client, and customer infinitely more than taking a code-first approach. This all has to do with the basics of problem-solving. That is, to solve a problem, you must understand it first. </p>

<br>

<p> Documentation must be rebuilt if you are dealing with a pre-existing code where it does not exist. In this case, it would be best to build the documentation in an incremental fashion documenting each component individually. </p>









